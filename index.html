<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>å¬ä¹¦å°åŠ©æ‰‹</title>
  <style>
    body {
      max-width: 700px;
      margin: auto;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
    }

    h1 {
      text-align: center;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 15px;
    }

    .controls label {
      margin-right: 5px;
      white-space: nowrap;
    }

    select, input[type="number"] {
      padding: 6px;
      font-size: 14px;
    }

    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    button {
      padding: 10px 16px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background-color: #4CAF50;
      color: white;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #45a049;
    }

    textarea {
      width: 100%;
      height: 60vh;
      margin-top: 10px;
      padding: 10px;
      font-size: 15px;
      line-height: 1.5;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>ğŸ“– å¬ä¹¦å°åŠ©æ‰‹</h1>

  <div class="controls">
    <label for="novelSelect">ğŸ“˜ é€‰æ‹©å°è¯´ï¼š</label>
    <select id="novelSelect"></select>

    <label for="chapterSelect">ğŸ“„ é€‰æ‹©ç« èŠ‚ï¼š</label>
    <select id="chapterSelect"></select>
  </div>

  <div class="controls">
    <label for="timer">â±ï¸ å®šæ—¶æœ—è¯»ï¼ˆåˆ†é’Ÿï¼‰ï¼š</label>
    <input type="number" id="timer" value="0" min="0" />
  </div>

  <div class="btn-group">
    <button onclick="play()">â–¶ï¸ æ’­æ”¾</button>
    <button onclick="pause()">â¸ï¸ æš‚åœ / ç»§ç»­</button>
    <button onclick="stop()">â¹ï¸ åœæ­¢</button>
  </div>

  <textarea id="textDisplay" readonly></textarea>

  <script>
    const GITHUB_USER = "hsira";
    const GITHUB_REPO = "hsira.github.io";
    const GITHUB_PATH = "";

    const fallbackFiles = [
      "novel1.txt", "part_1.txt", "part_2.txt", "fanren2464.txt"
    ];

    const novelSelect = document.getElementById("novelSelect");
    const chapterSelect = document.getElementById("chapterSelect");
    const textDisplay = document.getElementById("textDisplay");
    const timerInput = document.getElementById("timer");

    let chapters = [];
    let currentChapter = 0;
    const synth = window.speechSynthesis;
    let utterance = null;
    let endTime = null;

    async function fetchNovelFiles() {
      const api = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents/${GITHUB_PATH}`;
      try {
        const res = await fetch(api);
        if (!res.ok) throw new Error("GitHub API è¯·æ±‚å¤±è´¥");
        const data = await res.json();
        return data
          .filter(item => item.type === "file" && item.name.endsWith(".txt"))
          .map(item => ({ name: item.name, url: item.download_url }));
      } catch (e) {
        console.warn("âš ï¸ ä½¿ç”¨åå¤‡åˆ—è¡¨ï¼ŒåŸå› ï¼š", e.message);
        return fallbackFiles.map(f => ({ name: f, url: f }));
      }
    }

    async function initNovelSelect() {
      const fileList = await fetchNovelFiles();
      novelSelect.innerHTML = "";
      fileList.forEach((file, i) => {
        const opt = document.createElement("option");
        opt.value = file.url;
        opt.textContent = file.name;
        novelSelect.appendChild(opt);
      });
      loadNovel(novelSelect.value);
    }

    novelSelect.addEventListener("change", () => loadNovel(novelSelect.value));
    chapterSelect.addEventListener("change", () => {
      currentChapter = parseInt(chapterSelect.value);
      showChapter(currentChapter);
    });

    async function loadNovel(fileURL) {
      try {
        const res = await fetch(fileURL);
        if (!res.ok) throw new Error("åŠ è½½å¤±è´¥");
        const text = await res.text();
        splitChapters(text);
        currentChapter = 0;
        chapterSelect.value = 0;
        showChapter(0);
      } catch (e) {
        alert("åŠ è½½å°è¯´å¤±è´¥ï¼š" + e.message);
      }
    }

    function splitChapters(text) {
      chapters = [];
      const singleRe = /^ç¬¬[\u4e00-\u9fa5\d]{1,30}(?:ç« |å›|èŠ‚|é›†).*$/;
      const volChapRe = /^ç¬¬[\u4e00-\u9fa5\d]{1,30}å·.*?ç¬¬[\u4e00-\u9fa5\d]{1,30}(?:ç« |å›|èŠ‚|é›†).*$/;
      const lines = text.split(/\r?\n/);
      let cur = { title: "å¼€å§‹", content: "" };

      for (const raw of lines) {
        const line = raw.trim();
        if (singleRe.test(line) || volChapRe.test(line)) {
          if (cur.content) chapters.push(cur);
          cur = { title: line, content: "" };
        } else {
          cur.content += raw + "\n";
        }
      }
      if (cur.content) chapters.push(cur);
      populateChapterSelect();
    }

    function populateChapterSelect() {
      chapterSelect.innerHTML = "";
      chapters.forEach((c, i) => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent = c.title;
        chapterSelect.appendChild(opt);
      });
    }

    function showChapter(i) {
      if (chapters[i]) textDisplay.value = chapters[i].content;
    }

    function play() {
      if (synth.speaking || synth.pending) synth.cancel();
      const minutes = parseInt(timerInput.value);
      endTime = minutes > 0 ? Date.now() + minutes * 60000 : null;
      speakNextChapter(currentChapter);
    }

    function speakNextChapter(idx) {
      if (endTime && Date.now() >= endTime) {
        alert("æœ—è¯»æ—¶é—´å·²åˆ°ï¼Œå·²è‡ªåŠ¨åœæ­¢ã€‚");
        return;
      }
      if (!chapters[idx]) return;
      currentChapter = idx;
      chapterSelect.value = idx;
      textDisplay.value = chapters[idx].content;

      utterance = new SpeechSynthesisUtterance(chapters[idx].content);
      utterance.lang = "zh-CN";
      utterance.onend = () => {
        if (!synth.paused && (!endTime || Date.now() < endTime))
          speakNextChapter(idx + 1);
      };
      synth.speak(utterance);
    }

    function pause() {
      if (synth.speaking && !synth.paused) {
        synth.pause();
      } else if (synth.paused) {
        synth.resume();
      }
    }

    function stop() {
      synth.cancel();
      endTime = null;
    }

    initNovelSelect();
  </script>
</body>
</html>
